References:
1. https://www.cs.umd.edu/~nelson/classes/resources/cstyleguide/
2. 

Conventions:
1. Anything ending in _t is a typedef.
2. There shall be no direct printf calls. All console logging will go through a logger function
3. All pointers will be with the varaible name insteady of the type. Ex PointerType *typeName ... 
   and NOT PointerType* typeName ...
4. EVERY glfw and vulkan method must be ran through LOG_IF_ERROR(...) for proper error catching/announcing.
5. Follow the First-In-Last-Out principal for destruction to avoid potential unexpected interdependencies.
6. When defining a new struct, take the time to order the members in descending order of memory size. This
   is a memory optimization since all types take up 8 bytes on their own unless paired together with multiple
   of the same type.
7. Every time malloc(...) is written, IMMEDIATELY write the associated free(...) function so that it isn't 
   forgotten. Just do whatever you needed to bewtween those two calls. Unless that allocation is handled
   elsewhere, obviously.
8. All header files shall start with "#pragma once" to prevent any unintentional function/etc redefinitions.
9. Don't include the semicolon after any C macro. Because macros are replaced as in-lines at compile, the
   semicolon is just an unnecessary no-op that could be added.
10. Follow each malloc with a LOG_IF_ERROR to verify that memory allocation was successful.
11. Have the logged string of every LOG_IF_ERROR on a new line for code legibility.
12. For legibility, when using malloc, use sizeof(...) * numberOfItems in that order.
13. Function naming should be along the lines of objectModifiersVerb. Ex: swapchainDestroy(). This will make
    context-specific typing recommendations better.
14. Any function that logs things should start with log. Ex: LOG_IF_ERROR or logCapabilitiesInfo
15. Any struct member that contains a pointer shall start with a 'p' ex: 
   typedef struct { ... GLFWwindow *pWindow, ... } exampleStruct;
16. Whenever vkCreateSomething is called ensure that there is a vkDestroySomething of the same reference called
    during cleanup to prevent memory leaks.
17. CMake is configured to ALWAYS output to ./bin regardless of release type. This allows for having the same
    file access structure regardless of target.
18. There shall be no functions with () they must have at the very least (void). Ex: foo(void) NOT foo()

Engine:
1. The world will be defined by x/y chunk coordinates and a const max height. When referencing a chunk,
   there will be no y coordinate. Thus, this will happen on a purely 2d plane. These chunk coordinates
   are signed 32-bit integers.
2. DO NOT USE #pragma pack AT ALL (will break alignment for linear algebra used to copy into shaders)

References:
1. Shader compiling: man.archlinux.org/man/extra/shaderc/glslc.1.en
2. Vertex buffer: https://vulkan-tutorial.com/Vertex_buffers/Vertex_input_description
3. Rendering matricies: https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/
4. https://github.com/nothings/stb

TODO:
1. At some point in the future, check EVERY entry of LOG_IF_ERROR to ensure that if anything allocates memory but fails,
   that allocated memory is actually freed when VKResult != VK_SUCCESS. Ex: when trying to create framebuffers
2. The maximum number of simultaneous memory allocations is limited by the maxMemoryAllocationCount physical device limit,
   which may be as low as 4096 even on high end hardware. The right way to allocate memory for a large number of objects at
   the same time is to create a custom allocator that splits up a single allocation among many different objects by using the
   offset parameters that we've seen in many functions. See conclusion of https://vulkan-tutorial.com/Vertex_buffers/Staging_buffer
3. Driver developers recommend that you also store multiple buffers, like the vertex and index buffer, into a single VkBuffer
   and use offsets in commands like vkCmdBindVertexBuffers. The advantage is that your data is more cache friendly in that case,
   because it's closer together. It is even possible to reuse the same chunk of memory for multiple resources if they are not used
   during the same render operations, provided that their data is refreshed, of course. This is known as aliasing and some Vulkan
   functions have explicit flags to specify that you want to do this. See https://vulkan-tutorial.com/en/Vertex_buffers/Index_buffer
   conclusion.
5. When entering/changing worlds make sure to set glfw time back to zero
6. Consider changing the linear algebra to use pointers. Is this faster?
7. Consider adding a folder abstraction to contain everything in .voxelc kind of like .minecraft with just the exe in the root folder
8. Look into the 3d texture mapping discussion about linear tiling and 3d textures for voxel data
9. Create a setup command buffer like mentioned near the end of https://vulkan-tutorial.com/Texture_mapping/Images
12. Blockbench .glb model loader via https://github.com/jkuhlmann/cgltf